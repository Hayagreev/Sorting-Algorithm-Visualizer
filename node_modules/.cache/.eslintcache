[{"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/index.js":"1","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/App.js":"2","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/reportWebVitals.js":"3","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/Navbar.js":"4","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/SortingVis/SortingVis.js":"5","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/sortingAlgorithms/sortingAlgorithms.js":"6"},{"size":535,"mtime":1659210982256,"results":"7","hashOfConfig":"8"},{"size":284,"mtime":1659211187559,"results":"9","hashOfConfig":"8"},{"size":362,"mtime":1659210982256,"results":"10","hashOfConfig":"8"},{"size":222,"mtime":1659210982254,"results":"11","hashOfConfig":"8"},{"size":17525,"mtime":1659463603867,"results":"12","hashOfConfig":"8"},{"size":9857,"mtime":1659210982257,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","suppressedMessages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"iy27yz",{"filePath":"17","messages":"18","suppressedMessages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33"},"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/index.js",[],[],"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/App.js",[],[],"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/reportWebVitals.js",[],[],"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/Navbar.js",[],[],"/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/SortingVis/SortingVis.js",["34","35","36","37","38","39","40","41","42","43","44","45","46","47"],[],"import React from 'react';\nimport './SortingVis.css';\nimport * as sortingAlgorithms from '../sortingAlgorithms/sortingAlgorithms.js';\n\nconst DEFAULT_COLOR = \"rgb(192,192,192)\";\nconst SECONDARY_COLOR = 'red'\nconst POINTER_COLOR = 'blue';\nconst ENDING_COLOR = \"rgb(144, 238, 144)\";\n// const END_DELAY = 100; //number of animation speeds until the ending color disappears.\n\nvar ENDING_ANIMATION_SPEED_MS = 10;\nvar NUM_BARS = 300;\n\nvar mergeSort = false;\nvar quickSort = false;\nvar bubbleSort = false;\nvar heapSort = false;\n\n\n\nexport default class SortingVis extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            arr: [],\n            origArr: [],\n            numBars: 2,\n            animationSpeed: 1,\n        };\n\n        this.updateNumBars = this.updateNumBars.bind(this);\n        this.updateAnimationSpeed = this.updateAnimationSpeed.bind(this);\n    }\n\n    \n    componentDidMount() {\n        this.resetArray();\n    }\n\n    resetArray() {\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n\n        const arr = [];\n        const origArr = [];\n        for(let i = 0; i < NUM_BARS; i++) {\n            const randNum = Math.floor(Math.random() * 590) + 10;\n            arr.push(randNum); //generates random number from 10 to 730, and pushes number into arr\n            origArr.push(randNum);\n        }\n\n        // const arr = [16, 7, 22, 3, 19, 9, 33];\n\n        // const origArr = [16, 7, 22, 3, 19, 9, 33];\n\n        this.setState({arr: arr, origArr: origArr});\n\n        // const arrStr = \"564px,207px,431px,110px,554px,378px,514px,64px,44px,244px,478px,61px,572px,303px,180px,352px,103px,366px,225px,297px,67px,281px,412px,344px,463px,410px,350px,225px,188px,22px,288px,156px,434px,376px,513px,54px,243px,210px,442px,533px,386px,416px,316px,173px,270px,272px,459px,14px,528px,73px,325px,18px,575px,251px,518px,55px,114px,559px,573px,557px,141px,96px,179px,493px,119px,374px,533px,547px,240px,577px,567px,28px,162px,538px,96px,444px,267px,311px,239px,542px,240px,537px,227px,65px,288px,98px,255px,450px,223px,413px,450px,599px,301px,588px,357px,49px,96px,380px,180px,350px,182px,377px,73px,206px,365px,262px,252px,62px,141px,455px,171px,17px,524px,187px,345px,235px,144px,131px,174px,91px,307px,527px,474px,65px,492px,221px,590px,243px,557px,464px,72px,172px,241px,402px,327px,591px,464px,373px,413px,116px,424px,265px,405px,139px,184px,28px,389px,292px,513px,118px,88px,129px,470px,176px,310px,209px,69px,478px,468px,153px,215px,518px,492px,195px,57px,20px,257px,164px,358px,517px,501px,227px,32px,133px,100px,470px,224px,460px,578px,245px,448px,18px,579px,131px,529px,536px,116px,153px,490px,512px,258px,586px,563px,43px,228px,153px,132px,363px,390px,343px,250px,412px,81px,87px,445px,292px,567px,482px,550px,500px,425px,571px,119px,15px,34px,372px,335px,481px,285px,16px,323px,556px,308px,332px,331px,584px,240px,374px,60px,156px,162px,595px,71px,46px,555px,241px,462px,37px,357px,598px,405px,551px,290px,329px,326px,345px,323px,228px,28px,194px,362px,69px,437px,394px,290px,270px,390px,435px,444px,65px,134px,22px,31px,522px,359px,269px,295px,535px,361px,63px,434px,136px,516px,208px,249px,325px,549px,451px,562px,565px,473px,290px,226px,575px,549px,217px,473px,484px,99px,259px,480px,409px,40px,324px,542px,431px,65px,28px,582px,154px\";\n        \n        // const arrStrSplit = arrStr.split(\"px,\");\n        // const arr = [];\n\n        // arrStrSplit.forEach(str => {\n        //     arr.push(Number(str));\n        // });\n\n        // arr.pop();\n        // arr.push(154);\n        // console.log(arr);\n\n        // this.setState({arr});\n    }\n\n    resetArrayToOriginalState() {\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n\n        const arrayBars = document.getElementsByClassName('array-bar');\n        const newArr = [];\n\n        for(var i = 0; i < this.state.origArr.length; i++) {\n            arrayBars[i].style.height = `${this.state.origArr[i]}px`;\n            newArr.push(this.state.origArr[i]);\n        }\n\n        this.setState({arr: newArr, origArr: this.state.origArr}, () => {\n            console.log(\"reset arr: \" + this.state.arr);\n        });\n\n        \n    }\n\n    mergeSort() {\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n        mergeSort = true;\n        const animations = sortingAlgorithms.mergeSortAnimations(this.state.arr);\n        const arrayBars = document.getElementsByClassName('array-bar');\n\n\n        for(var i = 0; i < animations.length; i++) {\n\n            if(animations[i].length == 2) {\n                const [barIndex, value] = animations[i];\n                const barStyle = arrayBars[barIndex].style;\n\n                setTimeout(() => {\n                    barStyle.backgroundColor = SECONDARY_COLOR;\n                    barStyle.height = `${value}`;\n                }, i * this.state.animationSpeed);\n\n                setTimeout(() => {\n                    barStyle.backgroundColor = DEFAULT_COLOR;\n                    barStyle.height = `${value}px`;\n                }, (i+1) * this.state.animationSpeed);\n\n            } else if(animations[i].length == 3) {\n                const [barOneIdx, barTwoIdx, color] = animations[i];\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n\n                setTimeout(() => {\n                    if(color == 0) {\n                        barOneStyle.backgroundColor = DEFAULT_COLOR;\n                        barTwoStyle.backgroundColor = DEFAULT_COLOR;\n                    } else if(color == 1) {\n                        barOneStyle.backgroundColor = SECONDARY_COLOR;\n                        barTwoStyle.backgroundColor = SECONDARY_COLOR;\n                    } else if(color == 2) {\n                        barOneStyle.backgroundColor = POINTER_COLOR;\n                        barTwoStyle.backgroundColor = POINTER_COLOR;\n                    }\n                }, i * this.state.animationSpeed);\n            }\n\n            \n        }\n\n\n        for(var j = 0; j < NUM_BARS; j++) {\n            const barStyle = arrayBars[j].style;\n            setTimeout(() => {\n                barStyle.backgroundColor = ENDING_COLOR;\n            }, (animations.length * this.state.animationSpeed + j * ENDING_ANIMATION_SPEED_MS));\n            \n        }\n\n        setTimeout(() => {\n            for(var j = 0; j < NUM_BARS; j++) {\n                const barStyle = arrayBars[j].style;\n                barStyle.backgroundColor = DEFAULT_COLOR;\n            }\n\n            mergeSort = false;\n            \n        }, (animations.length * this.state.animationSpeed + NUM_BARS * ENDING_ANIMATION_SPEED_MS));\n\n        \n    }\n\n    quickSort() {\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n\n        const arrUnsorted = this.state.arr.slice().sort((a, b) => a-b);\n        const animations = sortingAlgorithms.quickSortAnimations(this.state.arr);\n\n        const arrayBars = document.getElementsByClassName('array-bar');\n\n        quickSort = true;\n\n        console.log(\"Comparing native sort with my sort: \" + equal(arrUnsorted, this.state.arr));\n\n        for(var i = 0; i < animations.length; i++) {\n\n            if(animations[i].length == 2) {\n                const [barIndex, color] = animations[i];\n                const barStyle = arrayBars[barIndex].style;\n\n                if(color == 0) {\n                    setTimeout(() => {\n                        barStyle.backgroundColor = DEFAULT_COLOR;\n                    }, i * this.state.animationSpeed);\n                } else if(color == 1) {\n                    setTimeout(() => {\n                        barStyle.backgroundColor = SECONDARY_COLOR;\n                    }, i * this.state.animationSpeed);\n                } else if(color == 2) {\n                    setTimeout(() => {\n                        barStyle.backgroundColor = 'green';\n                    }, i * this.state.animationSpeed);\n                }\n\n            } else if(animations[i].length == 3) {\n                const [barOneIdx, barTwoIdx, swap] = animations[i];\n\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n\n                setTimeout(() => {\n\n                    \n                    barOneStyle.backgroundColor = SECONDARY_COLOR;\n                    barTwoStyle.backgroundColor = SECONDARY_COLOR;\n\n                    if(swap) {\n                        var tmpHeight = barOneStyle.height;\n                        barOneStyle.height = `${barTwoStyle.height}`;\n                        barTwoStyle.height = `${tmpHeight}`;\n                    } else {\n                        console.log(\"SWAP is false\");\n                    }\n                    \n              }, i * this.state.animationSpeed);\n\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = DEFAULT_COLOR;\n                    barTwoStyle.backgroundColor = DEFAULT_COLOR;\n              }, (i+1) * this.state.animationSpeed);\n\n            } else {\n                console.log(\"Unknown animations length\");\n            }\n        }\n\n        for(var j = 0; j < NUM_BARS; j++) {\n            const barStyle = arrayBars[j].style;\n            setTimeout(() => {\n                barStyle.backgroundColor = ENDING_COLOR;\n            }, (animations.length * this.state.animationSpeed + j * ENDING_ANIMATION_SPEED_MS));\n            \n        }\n\n        setTimeout(() => {\n            for(var j = 0; j < NUM_BARS; j++) {\n                const barStyle = arrayBars[j].style;\n                barStyle.backgroundColor = DEFAULT_COLOR;\n            }\n\n            quickSort = false;\n            \n        }, (animations.length * this.state.animationSpeed + NUM_BARS * ENDING_ANIMATION_SPEED_MS));\n\n        var arrayBarsArr = [];\n        for(var i = 0; i < arrayBars.length; i++) {\n            arrayBarsArr.push(arrayBars[i].style.height);\n        }\n        console.log(\"Array bars arr:\" + arrayBarsArr);\n    }\n\n    heapSort() {\n\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n\n        var animations = sortingAlgorithms.heapSortAnimations(this.state.arr);\n        console.log(\"Sorted array: \" + this.state.arr);\n        console.log(\"Animations: \" + animations);\n\n        heapSort = true;\n\n        const arrayBars = document.getElementsByClassName('array-bar');\n\n        for(var i = 0; i < animations.length; i++) {\n            if(animations[i].length == 3) {\n                const [barOneIdx, barTwoIdx, swap] = animations[i];\n\n                const barOneStyle = arrayBars[barOneIdx].style;\n                const barTwoStyle = arrayBars[barTwoIdx].style;\n\n                setTimeout(() => {\n                    barOneStyle.backgroundColor = SECONDARY_COLOR;\n                    barTwoStyle.backgroundColor = SECONDARY_COLOR;\n              }, i * this.state.animationSpeed);\n\n                setTimeout(() => {\n\n                    if(swap) {\n                        var tmpHeight = barOneStyle.height;\n\n                        barOneStyle.height = `${barTwoStyle.height}`;\n                        barTwoStyle.height = `${tmpHeight}`;\n                    }\n\n                    barOneStyle.backgroundColor = DEFAULT_COLOR;\n                    barTwoStyle.backgroundColor = DEFAULT_COLOR;\n              }, (i+1) * this.state.animationSpeed);\n\n            }\n        }\n\n        for(var j = 0; j < NUM_BARS; j++) {\n            const barStyle = arrayBars[j].style;\n            setTimeout(() => {\n                barStyle.backgroundColor = ENDING_COLOR;\n            }, (animations.length * this.state.animationSpeed + j * ENDING_ANIMATION_SPEED_MS));\n            \n        }\n\n        setTimeout(() => {\n            for(var j = 0; j < NUM_BARS; j++) {\n                const barStyle = arrayBars[j].style;\n                barStyle.backgroundColor = DEFAULT_COLOR;\n            }\n\n            heapSort = false;\n            \n        }, (animations.length * this.state.animationSpeed + NUM_BARS * ENDING_ANIMATION_SPEED_MS));\n\n    }\n\n    bubbleSort() {\n\n        if(quickSort || bubbleSort || heapSort || mergeSort) {\n            return;\n        }\n\n        const animations = sortingAlgorithms.bubbleSortAnimations(this.state.arr);\n        const arrayBars = document.getElementsByClassName('array-bar');\n\n        bubbleSort = true;\n\n        for(var i = 0; i < animations.length; i++) {\n\n            const [barOneIdx, barTwoIdx, swap] = animations[i];\n\n            const barOneStyle = arrayBars[barOneIdx].style;\n            const barTwoStyle = arrayBars[barTwoIdx].style;\n\n            setTimeout(() => {\n                barOneStyle.backgroundColor = SECONDARY_COLOR;\n                barTwoStyle.backgroundColor = SECONDARY_COLOR;\n\n                \n              }, i * this.state.animationSpeed);\n\n            setTimeout(() => {\n\n                if(swap) {\n                    var tmpHeight = barOneStyle.height;\n\n                    barOneStyle.height = `${barTwoStyle.height}`;\n                    barTwoStyle.height = `${tmpHeight}`;\n                }\n\n                barOneStyle.backgroundColor = DEFAULT_COLOR;\n                barTwoStyle.backgroundColor = DEFAULT_COLOR;\n              }, (i+1) * this.state.animationSpeed);\n            \n        }\n\n        for(var j = 0; j < NUM_BARS; j++) {\n            const barStyle = arrayBars[j].style;\n            setTimeout(() => {\n                barStyle.backgroundColor = ENDING_COLOR;\n            }, (animations.length * this.state.animationSpeed + j * ENDING_ANIMATION_SPEED_MS));\n            \n        }\n\n        setTimeout(() => {\n            for(var j = 0; j < NUM_BARS; j++) {\n                const barStyle = arrayBars[j].style;\n                barStyle.backgroundColor = DEFAULT_COLOR;\n            }\n\n            bubbleSort = false;\n            \n        }, (animations.length * this.state.animationSpeed + NUM_BARS * ENDING_ANIMATION_SPEED_MS));\n    }\n\n    \n    updateNumBars(e) {\n        console.log(\"here\");\n        NUM_BARS = e.target.value;\n        console.log(NUM_BARS);\n        this.resetArray();\n    }\n\n    updateAnimationSpeed(e) {\n        this.setState({animationSpeed: e.target.value});\n    }\n\n    render() {\n        const arr = this.state.arr;       \n\n        return (\n\n            <div className = \"array-container\">\n\n                <h3 className=\"note\">Please note that there is a small chance of a glitch occuring in the rendering at low animation speeds when sorting due to the rapid switching of bars, causing the final array to appear unsorted (as some bars will be a higher/lower height than they should be). When this glitch happens, please click the \"Reset Array to Original State\" button, and retry the sorting algorithm. </h3>\n\n                <div>\n                    <input \n                      className=\"slider\" \n                      type=\"range\" \n                      id=\"arr-size\" \n                      name=\"Array Size\"\n                      min=\"2\" \n                      max=\"300\" \n                      defaultValue=\"300\" \n                      step=\"1\" \n                      //onChange={this.updateNumBars} \n                      onInput={this.updateNumBars} \n                    />\n                    <label htmlFor=\"Array Size\">Array Size [Currently: {NUM_BARS}]</label>\n                    \n                </div>\n\n                <div>\n                    <input \n                      className=\"slider\" \n                      type=\"range\" \n                      id=\"animation-speed\" \n                      name=\"Animation Speed\" \n                      min=\"1\" \n                      max=\"300\" \n                      defaultValue=\"10\" \n                      step=\"1\" \n                      //onChange={this.updateNumBars} \n                      onInput={this.updateAnimationSpeed}\n                    />\n                    <label htmlFor=\"Animation Speed\">Animation Speed [Currently: {this.state.animationSpeed} ms/animation]</label>\n                </div>\n\n                <div className=\"arrays\">\n                    {arr.map((value, idx) => (\n                        <div className=\"array-bar\" key={idx} style={{backgroundColor: DEFAULT_COLOR, height: `${value}px`,}}>\n                            \n                        </div>\n                    ))}\n                </div>\n                \n\n                <div className=\"button-container\">\n                    <button className=\"gradient-button\" onClick = {() => this.resetArray()}>Generate New Array</button>\n                    <button className=\"gradient-button\" onClick = {() => this.resetArrayToOriginalState()}>Reset Array to Original State</button>\n                    <button className=\"gradient-button\" onClick = {() => this.mergeSort()}>Merge Sort</button>\n                    <button className=\"gradient-button\" onClick = {() => this.quickSort()}>Quick Sort</button>\n                    <button className=\"gradient-button\" onClick = {() => this.heapSort()}>Heap Sort</button>\n                    <button className=\"gradient-button\" onClick = {() => this.bubbleSort()}>Bubble Sort</button>\n                </div>\n            </div>\n        );\n    }\n\n    \n}\n\nfunction equal(arrayOne, arrayTwo) {    \n    for(var i = 0; i < arrayOne.length; i++) {\n        if(arrayOne[i] == arrayTwo[i]) {\n            continue;\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction printArr(arr) {\n    for(var i = 0; i < arr.length; i++) {\n        console.log(i);\n    }\n}\n\n","/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/sortingAlgorithms/sortingAlgorithms.js",["48","49","50","51","52"],[],"//bubble sort\nexport const bubbleSortAnimations = (arr) => {\n  var animations = [];\n  for (var i = 0; i < arr.length - 1; i++) {\n    for (var j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        animations.push([j, j + 1, true]); //animations is array of arrays (in form [[val1, val2, swapped]])\n      } else {\n        animations.push([j, j + 1, false]);\n      }\n    }\n  }\n\n  return animations;\n};\n\n//quick sort\nexport const quickSortAnimations = (arr) => {\n  var animations = [];\n  quickSortAnimationsP(arr, 0, arr.length - 1, animations);\n  return animations;\n};\n\nfunction quickSortAnimationsP(arr, lowIndex, highIndex, animations) {\n  if (lowIndex >= highIndex) {\n    return;\n  }\n\n  var pivotIndex = getPivot(lowIndex, highIndex);\n  var pivot = arr[pivotIndex];\n  animations.push([pivotIndex, 2]); //[] in form of [index, color]. Note: 2 means green, 1 is secondary color, 0 is primary color\n\n  swap(arr, pivotIndex, highIndex);\n  animations.push([pivotIndex, highIndex, true]); //[] in form of [index1, index2, shouldSwap]\n\n  animations.push([highIndex, 2]);\n\n  var leftPointer = partition(arr, lowIndex, highIndex, pivot, animations);\n\n  animations.push([highIndex, 0]);\n\n  quickSortAnimationsP(arr, lowIndex, leftPointer - 1, animations);\n  quickSortAnimationsP(arr, leftPointer + 1, highIndex, animations);\n}\n\nfunction partition(arr, lowIndex, highIndex, pivot, animations) {\n  var leftPointer = lowIndex;\n  var rightPointer = highIndex;\n\n  animations.push([leftPointer, 1]);\n\n  animations.push([rightPointer, 1]);\n\n  while (leftPointer < rightPointer) {\n    while (arr[leftPointer] <= pivot && leftPointer < rightPointer) {\n      animations.push([leftPointer, 0]);\n      leftPointer++;\n      animations.push([leftPointer, 1]);\n    }\n\n    while (arr[rightPointer] >= pivot && leftPointer < rightPointer) {\n      animations.push([rightPointer, 0]);\n      rightPointer--;\n      animations.push([rightPointer, 1]);\n    }\n\n    swap(arr, leftPointer, rightPointer);\n    animations.push([leftPointer, rightPointer, true]);\n  }\n\n  if (arr[leftPointer] > arr[highIndex]) {\n    swap(arr, leftPointer, highIndex);\n    animations.push([leftPointer, highIndex, true]);\n  } else {\n    leftPointer = highIndex;\n  }\n\n  animations.push([leftPointer, 0]);\n  animations.push([rightPointer, 0]);\n\n  return leftPointer;\n}\n\n// function quickSortAnimationsP(arr, low, high, animations) {\n//   if (low < high) {\n//     // pi is partitioning index, arr[p]\n//     // is now at right place\n//     let pi = partition(arr, low, high, animations);\n\n//     // Separately sort elements before\n//     // partition and after partition\n//     quickSortAnimationsP(arr, low, pi - 1, animations);\n//     quickSortAnimationsP(arr, pi + 1, high, animations);\n//   }\n// }\n\n// function partition(arr, low, high, animations) {\n//   // pivot\n//   let pivot = arr[high];\n\n//   // Index of smaller element and\n//   // indicates the right position\n//   // of pivot found so far\n//   let leftPointer = low;\n\n//   for (let j = low; j <= high - 1; j++) {\n//     // If current element is smaller\n//     // than the pivot\n//     if (arr[j] < pivot) {\n//       // Increment index of\n//       // smaller element\n\n//       swap(arr, leftPointer, j);\n//       animations.push([leftPointer, j, true]);\n//       leftPointer++;\n//     }\n//   }\n//   swap(arr, leftPointer, high);\n//   animations.push([leftPointer, high, true]);\n//   return leftPointer;\n// }\n\nfunction getPivot(lowIndex, highIndex) {\n  return Math.floor(Math.random() * (highIndex - lowIndex) + 1) + lowIndex;\n}\n\n//merge sort\n\nexport const mergeSortAnimations = (arr) => {\n  var animations = [];\n  mergeSortAnimationsP(arr, 0, arr.length - 1, animations);\n  console.log(animations);\n  return animations;\n};\n\nfunction mergeSortAnimationsP(arr, startInd, endInd, animations) {\n  var arrLen = arr.length;\n\n  if (arrLen < 2) {\n    return;\n  }\n\n  var midIndex = Math.floor(arrLen / 2);\n  var leftHalf = [[], startInd, startInd + midIndex - 1];\n  var rightHalf = [[], startInd + midIndex, endInd];\n\n  for (var i = 0; i < midIndex; i++) {\n    leftHalf[0].push(arr[i]);\n  }\n\n  for (var i = midIndex; i < arrLen; i++) {\n    rightHalf[0].push(arr[i]);\n  }\n\n  mergeSortAnimationsP(leftHalf[0], leftHalf[1], leftHalf[2], animations);\n  mergeSortAnimationsP(rightHalf[0], rightHalf[1], rightHalf[2], animations);\n\n  merge(arr, leftHalf, rightHalf, animations);\n}\n\nfunction merge(arr, leftHalf, rightHalf, animations) {\n  //note: leftHalf is [[array to be sorted], startInd, endInd]; same for rightHalf\n  var leftLen = leftHalf[0].length;\n  var rightLen = rightHalf[0].length;\n\n  var leftIt = 0,\n    rightIt = 0,\n    arrIt = 0;\n\n  var leftPointer = leftIt + leftHalf[1];\n  var rightPointer = rightIt + rightHalf[1];\n\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 0]);\n\n  while (leftIt < leftLen && rightIt < rightLen) {\n    if (leftHalf[0][leftIt] <= rightHalf[0][rightIt]) {\n      arr[arrIt] = leftHalf[0][leftIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]]; // need to do leftHalf[1] + leftIt + rightIt because we want actual index in arr (leftIt and rightIt mark the number of numbers already inserted into arr)\n      animations.push(arrToPush);\n\n      leftIt++;\n\n      leftPointer = leftIt + leftHalf[1];\n      if (leftPointer > leftLen - 1) {\n        leftPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n      animations.push([leftPointer, rightPointer, 0]);\n    } else {\n      arr[arrIt] = rightHalf[0][rightIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n      animations.push(arrToPush);\n\n      rightIt++;\n\n      rightPointer = rightIt + rightHalf[1];\n      if (rightPointer > rightLen - 1) {\n        rightPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n      animations.push([leftPointer, rightPointer, 0]);\n    }\n\n    arrIt++;\n  }\n\n  while (leftIt < leftLen) {\n    arr[arrIt] = leftHalf[0][leftIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush); //format: [index in overall array, height of box (number)]\n\n    arrIt++;\n    leftIt++;\n\n    leftPointer = leftIt + leftHalf[1];\n    if (leftPointer > leftLen - 1) {\n      leftPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n\n  while (rightIt < rightLen) {\n    arr[arrIt] = rightHalf[0][rightIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush);\n\n    arrIt++;\n    rightIt++;\n\n    rightPointer = rightIt + rightHalf[1];\n    if (rightPointer > rightLen - 1) {\n      rightPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n}\n\n//Heap sort\nexport const heapSortAnimations = (arr) => {\n  var animations = [];\n  heapSortAnimationsP(arr, arr.length, animations);\n  return animations;\n};\n\nfunction heapSortAnimationsP(arr, arrLen, animations) {\n  if (arrLen < 2) {\n    return;\n  }\n\n  for (var i = Math.floor(arrLen / 2) - 1; i >= 0; i--) {\n    heapify(arr, arrLen, i, animations);\n  }\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    swap(arr, 0, i);\n    animations.push([0, i, true]);\n    arrLen--;\n    heapify(arr, arrLen, 0, animations);\n  }\n}\n\nfunction heapify(arr, arrLen, parentIndex, animations) {\n  //i is parent index\n  var largestParentIndex = parentIndex;\n  const leftChild = 2 * parentIndex + 1;\n  const rightChild = 2 * parentIndex + 2;\n\n  if (leftChild < arrLen && arr[leftChild] > arr[largestParentIndex]) {\n    largestParentIndex = leftChild;\n  }\n\n  if (rightChild < arrLen && arr[rightChild] > arr[largestParentIndex]) {\n    largestParentIndex = rightChild;\n  }\n\n  if (largestParentIndex != parentIndex) {\n    swap(arr, parentIndex, largestParentIndex);\n    animations.push([parentIndex, largestParentIndex, true]);\n\n    heapify(arr, arrLen, largestParentIndex, animations);\n  }\n}\n\n// function heapSortAnimationsP(arr, animations) {\n//   if (arr.length < 2) {\n//     return arr;\n//   }\n\n//   let arrLen = arr.length;\n//   for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\n//     sortParentAndChild(arr, arrLen, i, animations);\n//   }\n\n//   for (let i = arr.length - 1; i > 0; i--) {\n//     swap(arr, 0, i);\n//     animations.push(0, i, true);\n//     arrLen--;\n//     sortParentAndChild(arr, arrLen, 0, animations);\n//   }\n\n//   return arr;\n// }\n\n// function sortParentAndChild(arr, arrLen, parentIndex, animations) {\n//   const leftIndex = parentIndex * 2 + 1;\n//   const rightIndex = parentIndex * 2 + 2;\n\n//   let maxIndex = parentIndex;\n//   if (leftIndex < arrLen && arr[leftIndex] > arr[maxIndex]) {\n//     maxIndex = leftIndex;\n//   }\n\n//   if (rightIndex < arrLen && arr[rightIndex] > arr[maxIndex]) {\n//     maxIndex = rightIndex;\n//   }\n\n//   if (maxIndex !== parentIndex) {\n//     swap(arr, parentIndex, maxIndex);\n//     animations.push([parentIndex, maxIndex, true]);\n//     sortParentAndChild(arr, arrLen, maxIndex, animations);\n//   }\n// }\n\nfunction swap(arr, ind1, ind2) {\n  var temp = arr[ind1];\n  arr[ind1] = arr[ind2];\n  arr[ind2] = temp;\n}\n",{"ruleId":"53","severity":1,"message":"54","line":107,"column":37,"nodeType":"55","messageId":"56","endLine":107,"endColumn":39},{"ruleId":"53","severity":1,"message":"54","line":121,"column":44,"nodeType":"55","messageId":"56","endLine":121,"endColumn":46},{"ruleId":"53","severity":1,"message":"54","line":127,"column":30,"nodeType":"55","messageId":"56","endLine":127,"endColumn":32},{"ruleId":"53","severity":1,"message":"54","line":130,"column":37,"nodeType":"55","messageId":"56","endLine":130,"endColumn":39},{"ruleId":"53","severity":1,"message":"54","line":133,"column":37,"nodeType":"55","messageId":"56","endLine":133,"endColumn":39},{"ruleId":"53","severity":1,"message":"54","line":181,"column":37,"nodeType":"55","messageId":"56","endLine":181,"endColumn":39},{"ruleId":"53","severity":1,"message":"54","line":185,"column":26,"nodeType":"55","messageId":"56","endLine":185,"endColumn":28},{"ruleId":"53","severity":1,"message":"54","line":189,"column":33,"nodeType":"55","messageId":"56","endLine":189,"endColumn":35},{"ruleId":"53","severity":1,"message":"54","line":193,"column":33,"nodeType":"55","messageId":"56","endLine":193,"endColumn":35},{"ruleId":"53","severity":1,"message":"54","line":199,"column":44,"nodeType":"55","messageId":"56","endLine":199,"endColumn":46},{"ruleId":"57","severity":1,"message":"58","line":250,"column":17,"nodeType":"59","messageId":"60","endLine":250,"endColumn":18},{"ruleId":"53","severity":1,"message":"54","line":271,"column":37,"nodeType":"55","messageId":"56","endLine":271,"endColumn":39},{"ruleId":"53","severity":1,"message":"54","line":457,"column":24,"nodeType":"55","messageId":"56","endLine":457,"endColumn":26},{"ruleId":"61","severity":1,"message":"62","line":467,"column":10,"nodeType":"59","messageId":"63","endLine":467,"endColumn":18},{"ruleId":"57","severity":1,"message":"58","line":152,"column":12,"nodeType":"59","messageId":"60","endLine":152,"endColumn":13},{"ruleId":"57","severity":1,"message":"64","line":194,"column":11,"nodeType":"59","messageId":"60","endLine":194,"endColumn":20},{"ruleId":"57","severity":1,"message":"64","line":213,"column":9,"nodeType":"59","messageId":"60","endLine":213,"endColumn":18},{"ruleId":"57","severity":1,"message":"64","line":230,"column":9,"nodeType":"59","messageId":"60","endLine":230,"endColumn":18},{"ruleId":"53","severity":1,"message":"65","line":284,"column":26,"nodeType":"55","messageId":"56","endLine":284,"endColumn":28},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'i' is already defined.","Identifier","redeclared","no-unused-vars","'printArr' is defined but never used.","unusedVar","'arrToPush' is already defined.","Expected '!==' and instead saw '!='."]