{"ast":null,"code":"//bubble sort\nexport const bubbleSortAnimations = arr => {\n  var animations = [];\n\n  for (var i = 0; i < arr.length - 1; i++) {\n    for (var j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        animations.push([j, j + 1, true]); //animations is array of arrays (in form [[val1, val2, swapped]])\n      } else {\n        animations.push([j, j + 1, false]);\n      }\n    }\n  }\n\n  return animations;\n}; //quick sort\n\nexport const quickSortAnimations = arr => {\n  var animations = [];\n  quickSortAnimationsP(arr, 0, arr.length - 1, animations);\n  return animations;\n};\n\nfunction quickSortAnimationsP(arr, lowIndex, highIndex, animations) {\n  if (lowIndex >= highIndex) {\n    return;\n  }\n\n  var pivotIndex = getPivot(lowIndex, highIndex);\n  var pivot = arr[pivotIndex];\n  animations.push([pivotIndex, 2]); //[] in form of [index, color]. Note: 2 means green, 1 is secondary color, 0 is primary color\n\n  swap(arr, pivotIndex, highIndex);\n  animations.push([pivotIndex, highIndex, true]); //[] in form of [index1, index2, shouldSwap]\n\n  animations.push([highIndex, 2]);\n  var leftPointer = partition(arr, lowIndex, highIndex, pivot, animations);\n  animations.push([highIndex, 0]);\n  quickSortAnimationsP(arr, lowIndex, leftPointer - 1, animations);\n  quickSortAnimationsP(arr, leftPointer + 1, highIndex, animations);\n}\n\nfunction partition(arr, lowIndex, highIndex, pivot, animations) {\n  var leftPointer = lowIndex;\n  var rightPointer = highIndex;\n  animations.push([leftPointer, 1]);\n  animations.push([rightPointer, 1]);\n\n  while (leftPointer < rightPointer) {\n    while (arr[leftPointer] <= pivot && leftPointer < rightPointer) {\n      animations.push([leftPointer, 0]);\n      leftPointer++;\n      animations.push([leftPointer, 1]);\n    }\n\n    while (arr[rightPointer] >= pivot && leftPointer < rightPointer) {\n      animations.push([rightPointer, 0]);\n      rightPointer--;\n      animations.push([rightPointer, 1]);\n    }\n\n    swap(arr, leftPointer, rightPointer);\n    animations.push([leftPointer, rightPointer, true]);\n  }\n\n  if (arr[leftPointer] > arr[highIndex]) {\n    swap(arr, leftPointer, highIndex);\n    animations.push([leftPointer, highIndex, true]);\n  } else {\n    leftPointer = highIndex;\n  }\n\n  animations.push([leftPointer, 0]);\n  animations.push([rightPointer, 0]);\n  return leftPointer;\n} // function quickSortAnimationsP(arr, low, high, animations) {\n//   if (low < high) {\n//     // pi is partitioning index, arr[p]\n//     // is now at right place\n//     let pi = partition(arr, low, high, animations);\n//     // Separately sort elements before\n//     // partition and after partition\n//     quickSortAnimationsP(arr, low, pi - 1, animations);\n//     quickSortAnimationsP(arr, pi + 1, high, animations);\n//   }\n// }\n// function partition(arr, low, high, animations) {\n//   // pivot\n//   let pivot = arr[high];\n//   // Index of smaller element and\n//   // indicates the right position\n//   // of pivot found so far\n//   let leftPointer = low;\n//   for (let j = low; j <= high - 1; j++) {\n//     // If current element is smaller\n//     // than the pivot\n//     if (arr[j] < pivot) {\n//       // Increment index of\n//       // smaller element\n//       swap(arr, leftPointer, j);\n//       animations.push([leftPointer, j, true]);\n//       leftPointer++;\n//     }\n//   }\n//   swap(arr, leftPointer, high);\n//   animations.push([leftPointer, high, true]);\n//   return leftPointer;\n// }\n\n\nfunction getPivot(lowIndex, highIndex) {\n  return Math.floor(Math.random() * (highIndex - lowIndex) + 1) + lowIndex;\n} //merge sort\n\n\nexport const mergeSortAnimations = arr => {\n  var animations = [];\n  mergeSortAnimationsP(arr, 0, arr.length - 1, animations);\n  console.log(animations);\n  return animations;\n};\n\nfunction mergeSortAnimationsP(arr, startInd, endInd, animations) {\n  var arrLen = arr.length;\n\n  if (arrLen < 2) {\n    return;\n  }\n\n  var midIndex = Math.floor(arrLen / 2);\n  var leftHalf = [[], startInd, startInd + midIndex - 1];\n  var rightHalf = [[], startInd + midIndex, endInd];\n\n  for (var i = 0; i < midIndex; i++) {\n    leftHalf[0].push(arr[i]);\n  }\n\n  for (var i = midIndex; i < arrLen; i++) {\n    rightHalf[0].push(arr[i]);\n  }\n\n  mergeSortAnimationsP(leftHalf[0], leftHalf[1], leftHalf[2], animations);\n  mergeSortAnimationsP(rightHalf[0], rightHalf[1], rightHalf[2], animations);\n  merge(arr, leftHalf, rightHalf, animations);\n}\n\nfunction merge(arr, leftHalf, rightHalf, animations) {\n  //note: leftHalf is [[array to be sorted], startInd, endInd]; same for rightHalf\n  var leftLen = leftHalf[0].length;\n  var rightLen = rightHalf[0].length;\n  var leftIt = 0,\n      rightIt = 0,\n      arrIt = 0;\n  var leftPointer = leftIt + leftHalf[1];\n  var rightPointer = rightIt + rightHalf[1];\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 0]);\n\n  while (leftIt < leftLen && rightIt < rightLen) {\n    if (leftHalf[0][leftIt] <= rightHalf[0][rightIt]) {\n      arr[arrIt] = leftHalf[0][leftIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]]; // need to do leftHalf[1] + leftIt + rightIt because we want actual index in arr (leftIt and rightIt mark the number of numbers already inserted into arr)\n\n      animations.push(arrToPush);\n      leftIt++;\n      leftPointer = leftIt + leftHalf[1];\n\n      if (leftPointer > leftLen - 1) {\n        leftPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n\n      animations.push([leftPointer, rightPointer, 0]);\n    } else {\n      arr[arrIt] = rightHalf[0][rightIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n      animations.push(arrToPush);\n      rightIt++;\n      rightPointer = rightIt + rightHalf[1];\n\n      if (rightPointer > rightLen - 1) {\n        rightPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n\n      animations.push([leftPointer, rightPointer, 0]);\n    }\n\n    arrIt++;\n  }\n\n  while (leftIt < leftLen) {\n    arr[arrIt] = leftHalf[0][leftIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush); //format: [index in overall array, height of box (number)]\n\n    arrIt++;\n    leftIt++;\n    leftPointer = leftIt + leftHalf[1];\n\n    if (leftPointer > leftLen - 1) {\n      leftPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n\n  while (rightIt < rightLen) {\n    arr[arrIt] = rightHalf[0][rightIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush);\n    arrIt++;\n    rightIt++;\n    rightPointer = rightIt + rightHalf[1];\n\n    if (rightPointer > rightLen - 1) {\n      rightPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n} //Heap sort\n\n\nexport const heapSortAnimations = arr => {\n  var animations = [];\n  heapSortAnimationsP(arr, arr.length, animations);\n  return animations;\n};\n\nfunction heapSortAnimationsP(arr, arrLen, animations) {\n  if (arrLen < 2) {\n    return;\n  }\n\n  for (var i = Math.floor(arrLen / 2) - 1; i >= 0; i--) {\n    heapify(arr, arrLen, i, animations);\n  }\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    swap(arr, 0, i);\n    animations.push([0, i, true]);\n    arrLen--;\n    heapify(arr, arrLen, 0, animations);\n  }\n}\n\nfunction heapify(arr, arrLen, parentIndex, animations) {\n  //i is parent index\n  var largestParentIndex = parentIndex;\n  const leftChild = 2 * parentIndex + 1;\n  const rightChild = 2 * parentIndex + 2;\n\n  if (leftChild < arrLen && arr[leftChild] > arr[largestParentIndex]) {\n    largestParentIndex = leftChild;\n  }\n\n  if (rightChild < arrLen && arr[rightChild] > arr[largestParentIndex]) {\n    largestParentIndex = rightChild;\n  }\n\n  if (largestParentIndex != parentIndex) {\n    swap(arr, parentIndex, largestParentIndex);\n    animations.push([parentIndex, largestParentIndex, true]);\n    heapify(arr, arrLen, largestParentIndex, animations);\n  }\n} // function heapSortAnimationsP(arr, animations) {\n//   if (arr.length < 2) {\n//     return arr;\n//   }\n//   let arrLen = arr.length;\n//   for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\n//     sortParentAndChild(arr, arrLen, i, animations);\n//   }\n//   for (let i = arr.length - 1; i > 0; i--) {\n//     swap(arr, 0, i);\n//     animations.push(0, i, true);\n//     arrLen--;\n//     sortParentAndChild(arr, arrLen, 0, animations);\n//   }\n//   return arr;\n// }\n// function sortParentAndChild(arr, arrLen, parentIndex, animations) {\n//   const leftIndex = parentIndex * 2 + 1;\n//   const rightIndex = parentIndex * 2 + 2;\n//   let maxIndex = parentIndex;\n//   if (leftIndex < arrLen && arr[leftIndex] > arr[maxIndex]) {\n//     maxIndex = leftIndex;\n//   }\n//   if (rightIndex < arrLen && arr[rightIndex] > arr[maxIndex]) {\n//     maxIndex = rightIndex;\n//   }\n//   if (maxIndex !== parentIndex) {\n//     swap(arr, parentIndex, maxIndex);\n//     animations.push([parentIndex, maxIndex, true]);\n//     sortParentAndChild(arr, arrLen, maxIndex, animations);\n//   }\n// }\n\n\nfunction swap(arr, ind1, ind2) {\n  var temp = arr[ind1];\n  arr[ind1] = arr[ind2];\n  arr[ind2] = temp;\n}","map":{"version":3,"names":["bubbleSortAnimations","arr","animations","i","length","j","swap","push","quickSortAnimations","quickSortAnimationsP","lowIndex","highIndex","pivotIndex","getPivot","pivot","leftPointer","partition","rightPointer","Math","floor","random","mergeSortAnimations","mergeSortAnimationsP","console","log","startInd","endInd","arrLen","midIndex","leftHalf","rightHalf","merge","leftLen","rightLen","leftIt","rightIt","arrIt","arrToPush","heapSortAnimations","heapSortAnimationsP","heapify","parentIndex","largestParentIndex","leftChild","rightChild","ind1","ind2","temp"],"sources":["/Users/hayagreevdilip/Sorting-Algorithm-Visualizer/src/sortingAlgorithms/sortingAlgorithms.js"],"sourcesContent":["//bubble sort\nexport const bubbleSortAnimations = (arr) => {\n  var animations = [];\n  for (var i = 0; i < arr.length - 1; i++) {\n    for (var j = 0; j < arr.length - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        swap(arr, j, j + 1);\n        animations.push([j, j + 1, true]); //animations is array of arrays (in form [[val1, val2, swapped]])\n      } else {\n        animations.push([j, j + 1, false]);\n      }\n    }\n  }\n\n  return animations;\n};\n\n//quick sort\nexport const quickSortAnimations = (arr) => {\n  var animations = [];\n  quickSortAnimationsP(arr, 0, arr.length - 1, animations);\n  return animations;\n};\n\nfunction quickSortAnimationsP(arr, lowIndex, highIndex, animations) {\n  if (lowIndex >= highIndex) {\n    return;\n  }\n\n  var pivotIndex = getPivot(lowIndex, highIndex);\n  var pivot = arr[pivotIndex];\n  animations.push([pivotIndex, 2]); //[] in form of [index, color]. Note: 2 means green, 1 is secondary color, 0 is primary color\n\n  swap(arr, pivotIndex, highIndex);\n  animations.push([pivotIndex, highIndex, true]); //[] in form of [index1, index2, shouldSwap]\n\n  animations.push([highIndex, 2]);\n\n  var leftPointer = partition(arr, lowIndex, highIndex, pivot, animations);\n\n  animations.push([highIndex, 0]);\n\n  quickSortAnimationsP(arr, lowIndex, leftPointer - 1, animations);\n  quickSortAnimationsP(arr, leftPointer + 1, highIndex, animations);\n}\n\nfunction partition(arr, lowIndex, highIndex, pivot, animations) {\n  var leftPointer = lowIndex;\n  var rightPointer = highIndex;\n\n  animations.push([leftPointer, 1]);\n\n  animations.push([rightPointer, 1]);\n\n  while (leftPointer < rightPointer) {\n    while (arr[leftPointer] <= pivot && leftPointer < rightPointer) {\n      animations.push([leftPointer, 0]);\n      leftPointer++;\n      animations.push([leftPointer, 1]);\n    }\n\n    while (arr[rightPointer] >= pivot && leftPointer < rightPointer) {\n      animations.push([rightPointer, 0]);\n      rightPointer--;\n      animations.push([rightPointer, 1]);\n    }\n\n    swap(arr, leftPointer, rightPointer);\n    animations.push([leftPointer, rightPointer, true]);\n  }\n\n  if (arr[leftPointer] > arr[highIndex]) {\n    swap(arr, leftPointer, highIndex);\n    animations.push([leftPointer, highIndex, true]);\n  } else {\n    leftPointer = highIndex;\n  }\n\n  animations.push([leftPointer, 0]);\n  animations.push([rightPointer, 0]);\n\n  return leftPointer;\n}\n\n// function quickSortAnimationsP(arr, low, high, animations) {\n//   if (low < high) {\n//     // pi is partitioning index, arr[p]\n//     // is now at right place\n//     let pi = partition(arr, low, high, animations);\n\n//     // Separately sort elements before\n//     // partition and after partition\n//     quickSortAnimationsP(arr, low, pi - 1, animations);\n//     quickSortAnimationsP(arr, pi + 1, high, animations);\n//   }\n// }\n\n// function partition(arr, low, high, animations) {\n//   // pivot\n//   let pivot = arr[high];\n\n//   // Index of smaller element and\n//   // indicates the right position\n//   // of pivot found so far\n//   let leftPointer = low;\n\n//   for (let j = low; j <= high - 1; j++) {\n//     // If current element is smaller\n//     // than the pivot\n//     if (arr[j] < pivot) {\n//       // Increment index of\n//       // smaller element\n\n//       swap(arr, leftPointer, j);\n//       animations.push([leftPointer, j, true]);\n//       leftPointer++;\n//     }\n//   }\n//   swap(arr, leftPointer, high);\n//   animations.push([leftPointer, high, true]);\n//   return leftPointer;\n// }\n\nfunction getPivot(lowIndex, highIndex) {\n  return Math.floor(Math.random() * (highIndex - lowIndex) + 1) + lowIndex;\n}\n\n//merge sort\n\nexport const mergeSortAnimations = (arr) => {\n  var animations = [];\n  mergeSortAnimationsP(arr, 0, arr.length - 1, animations);\n  console.log(animations);\n  return animations;\n};\n\nfunction mergeSortAnimationsP(arr, startInd, endInd, animations) {\n  var arrLen = arr.length;\n\n  if (arrLen < 2) {\n    return;\n  }\n\n  var midIndex = Math.floor(arrLen / 2);\n  var leftHalf = [[], startInd, startInd + midIndex - 1];\n  var rightHalf = [[], startInd + midIndex, endInd];\n\n  for (var i = 0; i < midIndex; i++) {\n    leftHalf[0].push(arr[i]);\n  }\n\n  for (var i = midIndex; i < arrLen; i++) {\n    rightHalf[0].push(arr[i]);\n  }\n\n  mergeSortAnimationsP(leftHalf[0], leftHalf[1], leftHalf[2], animations);\n  mergeSortAnimationsP(rightHalf[0], rightHalf[1], rightHalf[2], animations);\n\n  merge(arr, leftHalf, rightHalf, animations);\n}\n\nfunction merge(arr, leftHalf, rightHalf, animations) {\n  //note: leftHalf is [[array to be sorted], startInd, endInd]; same for rightHalf\n  var leftLen = leftHalf[0].length;\n  var rightLen = rightHalf[0].length;\n\n  var leftIt = 0,\n    rightIt = 0,\n    arrIt = 0;\n\n  var leftPointer = leftIt + leftHalf[1];\n  var rightPointer = rightIt + rightHalf[1];\n\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n  animations.push([leftIt + leftHalf[1], rightIt + rightHalf[1], 0]);\n\n  while (leftIt < leftLen && rightIt < rightLen) {\n    if (leftHalf[0][leftIt] <= rightHalf[0][rightIt]) {\n      arr[arrIt] = leftHalf[0][leftIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]]; // need to do leftHalf[1] + leftIt + rightIt because we want actual index in arr (leftIt and rightIt mark the number of numbers already inserted into arr)\n      animations.push(arrToPush);\n\n      leftIt++;\n\n      leftPointer = leftIt + leftHalf[1];\n      if (leftPointer > leftLen - 1) {\n        leftPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n      animations.push([leftPointer, rightPointer, 0]);\n    } else {\n      arr[arrIt] = rightHalf[0][rightIt];\n      var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n      animations.push(arrToPush);\n\n      rightIt++;\n\n      rightPointer = rightIt + rightHalf[1];\n      if (rightPointer > rightLen - 1) {\n        rightPointer--;\n      }\n\n      animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n      animations.push([leftPointer, rightPointer, 0]);\n    }\n\n    arrIt++;\n  }\n\n  while (leftIt < leftLen) {\n    arr[arrIt] = leftHalf[0][leftIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush); //format: [index in overall array, height of box (number)]\n\n    arrIt++;\n    leftIt++;\n\n    leftPointer = leftIt + leftHalf[1];\n    if (leftPointer > leftLen - 1) {\n      leftPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n\n  while (rightIt < rightLen) {\n    arr[arrIt] = rightHalf[0][rightIt];\n    var arrToPush = [leftHalf[1] + leftIt + rightIt, arr[arrIt]];\n    animations.push(arrToPush);\n\n    arrIt++;\n    rightIt++;\n\n    rightPointer = rightIt + rightHalf[1];\n    if (rightPointer > rightLen - 1) {\n      rightPointer--;\n    }\n\n    animations.push([leftPointer, rightPointer, 2]); // form of [left pointer index, rightpointer index, color] --> 2 is pointer color, 1 is secondary color, 0 is primary color\n    animations.push([leftPointer, rightPointer, 0]);\n  }\n}\n\n//Heap sort\nexport const heapSortAnimations = (arr) => {\n  var animations = [];\n  heapSortAnimationsP(arr, arr.length, animations);\n  return animations;\n};\n\nfunction heapSortAnimationsP(arr, arrLen, animations) {\n  if (arrLen < 2) {\n    return;\n  }\n\n  for (var i = Math.floor(arrLen / 2) - 1; i >= 0; i--) {\n    heapify(arr, arrLen, i, animations);\n  }\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    swap(arr, 0, i);\n    animations.push([0, i, true]);\n    arrLen--;\n    heapify(arr, arrLen, 0, animations);\n  }\n}\n\nfunction heapify(arr, arrLen, parentIndex, animations) {\n  //i is parent index\n  var largestParentIndex = parentIndex;\n  const leftChild = 2 * parentIndex + 1;\n  const rightChild = 2 * parentIndex + 2;\n\n  if (leftChild < arrLen && arr[leftChild] > arr[largestParentIndex]) {\n    largestParentIndex = leftChild;\n  }\n\n  if (rightChild < arrLen && arr[rightChild] > arr[largestParentIndex]) {\n    largestParentIndex = rightChild;\n  }\n\n  if (largestParentIndex != parentIndex) {\n    swap(arr, parentIndex, largestParentIndex);\n    animations.push([parentIndex, largestParentIndex, true]);\n\n    heapify(arr, arrLen, largestParentIndex, animations);\n  }\n}\n\n// function heapSortAnimationsP(arr, animations) {\n//   if (arr.length < 2) {\n//     return arr;\n//   }\n\n//   let arrLen = arr.length;\n//   for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\n//     sortParentAndChild(arr, arrLen, i, animations);\n//   }\n\n//   for (let i = arr.length - 1; i > 0; i--) {\n//     swap(arr, 0, i);\n//     animations.push(0, i, true);\n//     arrLen--;\n//     sortParentAndChild(arr, arrLen, 0, animations);\n//   }\n\n//   return arr;\n// }\n\n// function sortParentAndChild(arr, arrLen, parentIndex, animations) {\n//   const leftIndex = parentIndex * 2 + 1;\n//   const rightIndex = parentIndex * 2 + 2;\n\n//   let maxIndex = parentIndex;\n//   if (leftIndex < arrLen && arr[leftIndex] > arr[maxIndex]) {\n//     maxIndex = leftIndex;\n//   }\n\n//   if (rightIndex < arrLen && arr[rightIndex] > arr[maxIndex]) {\n//     maxIndex = rightIndex;\n//   }\n\n//   if (maxIndex !== parentIndex) {\n//     swap(arr, parentIndex, maxIndex);\n//     animations.push([parentIndex, maxIndex, true]);\n//     sortParentAndChild(arr, arrLen, maxIndex, animations);\n//   }\n// }\n\nfunction swap(arr, ind1, ind2) {\n  var temp = arr[ind1];\n  arr[ind1] = arr[ind2];\n  arr[ind2] = temp;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}